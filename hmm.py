import numpy as np


def randomSequencegenerator(pi,A,B):
    
    #mapping corresponding number to observed state
    dict = {0: 'S', 1: 'A', 2: 'B', 3: 'C', 4:'D'} 

    finalSequence=[]
    for i in range(1,11):
        sequence=[]
        state=np.argmax(pi)
        observedState=1
        while observedState!=0:
            emission=B[state]
            #Estimating the observed state on basis of emission matrix
            obsState=np.random.choice([0,1,2,3,4],size=1,p=emission)
            observedState=obsState[0]
            #Adding the observed state to the sequence of observations
            sequence.append(dict[observedState])
            transition=A[state]
            #Estimating the next hidden state
            nextState=np.random.choice([0,1,2,3],size=1,p=transition)
            state=nextState[0]
        #10 sequences of Observations
        finalSequence.append(sequence)
    print("Random Sequences of observations based on HMM with λ1 parameters are as follows:")
    for i in finalSequence:
        print i

        
def forward(pi1,A1,B1,pi2,A2,B2,observations,sequences):
    for observation,sequence in zip(observations,sequences):
        
        #Caluclating p(O|λi) for HMM-1
        HMM1_pi=pi1
        HMM1_A=A1
        HMM1_B=B1
        no_states1 = pi1.shape[0]
        no_obs1 = len(observation)
        
        alpha1 = np.zeros((no_obs1, no_states1))
        
        # Starting t=1
        alpha1[0, :] = HMM1_pi * HMM1_B[:,observation[0]]

        # for remaining timestamps
        for i in range(1, no_obs1):
            for curr_state in range(no_states1):
                for prev_state in range(no_states1):
                    alpha1[i, curr_state] += alpha1[i-1, prev_state] * HMM1_A[prev_state, curr_state] * HMM1_B[curr_state, observation[i]]
        print(alpha1)
        #Caluclating p(O|λi) for HMM-2
        HMM2_pi=pi2
        HMM2_A=A2 
        HMM2_B=B2
        no_states2 = pi2.shape[0]
        no_obs2 = len(observation)
        
        alpha2 = np.zeros((no_obs2, no_states2))
        
        # Starting time t=1
        alpha2[0, :] = HMM2_pi * HMM2_B[:,observation[0]]

        # for remaining timestamps using recurrence relation
        for i in range(1, no_obs2):
            for curr_state in range(no_states2):
                for prev_state in range(no_states2):
                    alpha2[i, curr_state] += alpha2[i-1, prev_state] * HMM2_A[prev_state, curr_state] * HMM2_B[curr_state, observation[i]]
        
        print(sequence)
        if np.log(alpha1)[no_obs1-1][0]>np.log(alpha2)[no_obs2-1][0]:
            print("The above sequence is generated by HMM λ1")
        else:
            print("The above sequence is generated by HMM λ2")
        print("")
                
    
def viterbi(pi2,A2,B2,observations,sequences):
    for observation,sequence in zip(observations,sequences):
        HMM2_pi=pi2
        HMM2_A=A2
        HMM2_B=B2
        no_states2 = pi2.shape[0]
        no_obs2 = len(observation)
        
        delta2= np.zeros((no_obs2, no_states2))
        delta2.astype(float)
        
        #Initializing delta matrix with very small values (-infinity) for comparison
        delta2[:,:] = '-inf'
        
        # Starting time t=1
        Si2= np.zeros((no_obs2, no_states2),'int')
        
        delta2[0, :] = HMM2_pi * HMM2_B[:,observation[0]]
        
        # for remaining timestamps using recurrence relation
        for i in range(1, no_obs2):
            for curr_state in range(no_states2):
                for prev_state in range(no_states2):
                    value= HMM2_B[curr_state, observation[i]] * HMM2_A[prev_state, curr_state] * delta2[i-1, prev_state]
                    if(value>delta2[i,curr_state]):
                        delta2[i,curr_state]=value
                        Si2[i,curr_state]=prev_state
        
        backtracking=[]
        
        #first considering the final hidden state and then performing backtracking based on it
        backtracking.append(np.argmax(delta2[no_obs2-1,:]))
        
        #Usinng Si matrix for backtracking and getting the hidden states
        for i in range(no_obs2-1, 0, -1):
            backtracking.append(Si2[i, backtracking[-1]])
        hidden_states=list(reversed(backtracking))
        
        decoded_hidden_states=[]
        for i in hidden_states:
            decoded_hidden_states.append(i+1)
        
        print(sequence)
        print("Hidden states for the above sequence of observations using HMM λ2 is as follows:")
        print(decoded_hidden_states)
        print("")
        
   
  
    
def main():
    A1 = np.array([[1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0], [0.0, 0.4, 0.3, 0.3], [0.3, 0.2, 0.2, 0.3]] )
    pi1 = np.array([0.0, 1.0, 0.0, 0.0])
    B1 = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.5, 0.5, 0.0, 0.0], [0.0, 0.2, 0.2, 0.3, 0.3], [0.0, 0.0, 0.0, 0.5, 0.5]] )
    
    A2 = np.array([[1.0, 0.0, 0.0, 0.0], [0.1, 0.3, 0.5, 0.1], [0.1, 0.4, 0.3, 0.2], [0.1, 0.4, 0.2, 0.3]] )
    pi2 = np.array([0.0, 0.0, 0.0, 1.0])
    B2 = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.5, 0.0, 0.5], [0.0, 0.0, 0.5, 0.5, 0.0], [0.0, 0.5, 0.0, 0.0, 0.5]] )
    
    #Random Sequence generator - Q3 a)
    randomSequencegenerator(pi1,A1,B1)
    
    print("")
    print("===============================================")
    
    #forward Algorithm - Q3 b)
    print("Classification of sequences based on HMM parameters are as follows:")
    
    sequences=[['A','D','C','B','D','C','C','S'],['B','D','S'],['B','C','C','B','D','D','C','A','C','S'],
               ['A','C','D','S' ],['A','D','A','C','S'],['D','B','B','S'],['A','B','S'],
               ['D','D','B','D','D','B','A','C','C','D','A','B','B','C','D','B','B','B','S'],
               ['D','B','D','S'],['A','A','A','A','D','C','B','S']]
    mapping={'A':1,'B':2,'C':3,'D':4,'S':0}
    observations=[]
    
    for sequence in sequences:
        obs=[]
        for observation in sequence:
            obs.append(mapping[observation])
        observations.append(obs)
    
    forward(pi1,A1,B1,pi2,A2,B2,observations,sequences)
    print("===============================================")
    
    #Viterbi Algorithm - Q3 c)
    print("Hidden states for each sequence of observations using HMM λ2 is as below:")
    viterbi(pi2,A2,B2,observations,sequences)
    
if __name__ == "__main__":
    main()